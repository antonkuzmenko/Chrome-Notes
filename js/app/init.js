// Generated by CoffeeScript 1.6.2
(function() {
  var iterator,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.app = {
    Model: {},
    Collection: {},
    View: {},
    Mixin: {},
    Iterator: {},
    Template: {
      Folder: {},
      Note: {}
    }
  };

  iterator = (function() {
    return function() {
      var i;

      i = 0;
      return {
        next: function() {
          return ++i;
        },
        get: function() {
          return i;
        },
        set: function(newI) {
          return i = newI;
        }
      };
    };
  })();

  window.app.Iterator.folder = iterator();

  window.app.Iterator.note = iterator();

  Backbone.Model.prototype.toJSON = function() {
    var _ref;

    return _.extend({}, _.clone(this.attributes), {
      id: (_ref = this.id) != null ? _ref : this.cid
    });
  };

  Backbone.sync = function(method, model, options) {
    var data, id, modelId, storage, _ref;

    modelId = "" + model.type + "-" + model.id;
    id = model.id;
    storage = chrome.storage.local;
    switch (method) {
      case 'create':
      case 'update':
      case 'patch':
        data = {};
        data[modelId] = (_ref = options.attrs) != null ? _ref : model.toJSON(options);
        storage.set(data, function() {
          var errorMsg, _ref1;

          errorMsg = (_ref1 = chrome.runtime.lastError) != null ? _ref1.message : void 0;
          if (errorMsg != null) {
            return options.error(errorMsg);
          } else {
            options.success(data[modelId]);
            return storage.get(model.type, function(identifiers) {
              var ids, _ref2;

              if (identifiers[model.type] == null) {
                identifiers[model.type] = [];
              }
              ids = identifiers[model.type];
              if (_ref2 = model.id, __indexOf.call(ids, _ref2) < 0) {
                ids.push(model.id);
                return storage.set(identifiers);
              }
            });
          }
        });
        break;
      case 'delete':
        storage.remove(modelId, function() {
          var errorMsg, _ref1;

          errorMsg = (_ref1 = chrome.runtime.lastError) != null ? _ref1.message : void 0;
          if (errorMsg != null) {
            return options.error(errorMsg);
          } else {
            options.success('ok');
            return storage.get(model.type, function(identifiers) {
              var deletedIndex, ids;

              ids = identifiers[model.type];
              deletedIndex = ids.indexOf(id);
              if (deletedIndex !== -1) {
                ids.splice(deletedIndex, 1);
                return storage.set(identifiers);
              }
            });
          }
        });
        break;
      case 'read':
        storage.get(model.type, function(modelIds) {
          var errorMsg, models, modelsLen, _fn, _i, _len, _ref1, _ref2;

          errorMsg = (_ref1 = chrome.runtime.lastError) != null ? _ref1.message : void 0;
          if (errorMsg != null) {
            return options.error(errorMsg);
          } else {
            if (_.isEmpty(modelIds)) {
              return;
            }
            models = [];
            modelsLen = modelIds[model.type].length;
            _ref2 = modelIds[model.type];
            _fn = function(id) {
              return storage.get(model.type + '-' + id, function(data) {
                models.push(data[model.type + '-' + id]);
                if (modelsLen === models.length) {
                  return options.success(models);
                }
              });
            };
            for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
              id = _ref2[_i];
              _fn(id);
            }
          }
        });
    }
    model.trigger('request', model, {}, options);
    return null;
  };

}).call(this);

/*
//@ sourceMappingURL=init.map
*/
